{"version":3,"file":"adapters.js","sources":["../../../src/components/LocusZoom/adapters.js"],"sourcesContent":["import LocusZoom from \"locuszoom\";\nimport config from \"./config\"\n\n/*export interface RequestOptions {\n    chr?: string;\n    start?: number;\n    end?: number;\n    ld_population?: string;\n    ld_refvar?: string;\n    track?: string;\n}*/\n\nconst AssociationLZ = LocusZoom.Adapters.get(\"AssociationLZ\"),\n    LDServer = LocusZoom.Adapters.get(\"LDServer\"),\n    GeneLZ = LocusZoom.Adapters.get(\"GeneLZ\"),\n    RecombLZ = LocusZoom.Adapters.get(\"RecombLZ\");\n\n\nexport class CustomAssociationAdapter extends AssociationLZ {\n    /*constructor(config: any) {\n        config.prefix_namespace = false;\n        super(config);\n    }*/\n\n    _getURL(request_options) {\n        // Every adapter receives the info from plot.state, plus any additional request options calculated/added in the function `_buildrequest_options`\n        // The inputs to the function can be used to influence what query is constructed. Eg, since the current view region is stored in `plot.state`:\n        let { chr, start, end, track } = request_options;\n        // Fetch the region of interest from a hypothetical REST API that uses query parameters to define the region query, for a given study URL such as `data.example/gwas/<id>/?chr=_&start=_&end=_`\n        return `${this._url}/gwas?track=${track}&chromosome=${chr}&start=${Math.trunc(start)}&end=${Math.trunc(end)}`;\n    }\n\n    _buildRequestOptions(plot_state, ...dependent_data) {\n        const initialState = this._config.initial_state;\n        const requestOptions = Object.assign({\n            chr: plot_state.chr ? plot_state.chr : initialState.chr,\n            start: plot_state.chr ? plot_state.start : initialState.start,\n            end: plot_state.chr ? plot_state.end : initialState.end,\n            track: this._config.track\n        }, plot_state);\n\n        return requestOptions;\n    }\n\n    _normalizeResponse(raw_response, request_options) {\n        const { chr } = request_options;\n\n        // for some strange reason; the raw_response is a string\n        // even though the service returns an object\n        let response = JSON.parse(raw_response);\n\n        // catch empty spans\n        if (response.data.variant == null)\n            return [];\n\n        const records = response.data.variant.map((variant, index) => (\n            {\n                variant: variant,\n                pvalue: response.data.pvalue[index],\n                log_pvalue: response.data.log_pvalue[index],\n                chromosome: chr,\n                test_allele: response.data.test_allele[index],\n                position: parseInt(response.data.position[index])\n            }));\n\n        return records;\n    }\n}\n\nexport class CustomRecombAdapter extends RecombLZ {\n    _getURL(request_options) {\n        const { chr, start, end } = request_options;\n        return `${this._url}/recomb?chromosome=${chr}&start=${Math.trunc(start)}&end=${Math.trunc(end)}`;\n    }\n\n    _buildRequestOptions(plot_state, ...dependent_data) {\n        const initialState = this._config.initial_state;\n        const requestOptions = Object.assign({\n            chr: plot_state.chr ? plot_state.chr : initialState.chr,\n            start: plot_state.chr ? plot_state.start : initialState.start,\n            end: plot_state.chr ? plot_state.end : initialState.end\n        }, plot_state);\n\n        return requestOptions;\n    }\n}\n\nexport class CustomLDServerAdapter extends LDServer {\n    constructor(config) {\n        super(config);\n    }\n\n    // modified from https://statgen.github.io/locuszoom/docs/api/data_adapters.js.html#line478\n    // added types\n    __find_ld_refvar(state, assoc_data) {\n        const assoc_variant_name = this._findPrefixedKey(assoc_data[0], 'variant');\n        const assoc_logp_name = this._findPrefixedKey(assoc_data[0], 'log_pvalue');\n\n        let refvar = \"\";\n        let best_hit = {};\n\n        // Determine the reference variant (via user selected OR automatic-per-track)\n        if (state.ldrefvar) { // passed by state\n            refvar = state.ldrefvar;\n            best_hit = assoc_data.find((item) => item[assoc_variant_name] === refvar) || {};\n        }\n        else {\n            // find highest log-value and associated var spec\n            let best_logp = 0;\n            for (let item of assoc_data) {\n                const { [assoc_variant_name]: variant, [assoc_logp_name]: log_pvalue } = item;\n                if (item.hasOwnProperty('lz_is_ld_refvar')) {\n                    delete item.lz_is_ld_refvar; // for updates based on state\n                }\n                if (log_pvalue > best_logp) {\n                    best_logp = log_pvalue;\n                    refvar = variant;\n                    best_hit = item;\n                }\n            }\n        }\n\n        // Add a special field that is not part of the assoc or \n        // LD data from the server, but has significance for plotting.\n        //  Since we already know the best hit, it's easier to do this here rather than in annotate or join phase.\n        // fossilfriend: NOTE - this updates the best hit variant by reference\n        best_hit.lz_is_ld_refvar = true;\n\n        // Last step: sanity check the proposed reference variant. Is it inside the view region? If not, we're probably\n        //  remembering a user choice from before user jumped to a new region. LD should be relative to something nearby.\n\n        // NOTE: fossilfriend - removing this b/c when doing update based on table select, it's setting the refvar to null\n        // if the refvar is outside the current span\n        \n        /* let [chrom, pos, ...rest] = refvar.split(\":\");\n        let coord = +pos;\n        if ((coord && state.ldrefvar && state.chr) && (chrom !== String(state.chr) || coord < state.start || coord > state.end)) {\n            // Rerun this method, after clearing out the proposed reference variant. NOTE: Adapter call receives a\n            //   *copy* of plot.state, so wiping here doesn't remove the original value.\n            state.ldrefvar = null;\n            return this.__find_ld_refvar(state, assoc_data);\n        } */\n\n        return refvar;\n    }\n\n    _getURL(request_options) {\n        const { ld_population, ld_refvar } = request_options;\n        return `${this._url}/linkage?population=${ld_population}&variant=${ld_refvar}`;\n    }\n\n\n    _buildRequestOptions(plot_state, assoc_data) {\n        if (!assoc_data) {\n            throw new Error('LD request must depend on association data');\n        }\n\n        const base = super._buildRequestOptions(...arguments);\n        if (!assoc_data.length) {\n            // No variants, so no need to annotate association data with LD!\n            // may be buggy, if allowing multiple tracks in one graphic; see original LDServer adapter\n            base._skip_request = true;\n            return base;\n        }\n\n        const initialState = this._config.initial_state;\n\n        if (!plot_state.ld_refvar) { plot_state.ld_refvar = initialState.ldrefvar };\n        base.ld_refvar = this.__find_ld_refvar(plot_state, assoc_data);\n\n        const ld_population = plot_state.ld_population\n            ? plot_state.ld_population\n            : initialState.population\n                ? initialState.population\n                : config.DEFAULT_LD_POPULATION;\n\n        const requestOptions = Object.assign({}, base, { ld_population });\n\n        return requestOptions;\n    }\n\n    // GenomicsDB Webservice returns linked_variant and r_squared only to reduce repsonse\n    // size; need to convert to expected response, which includes \n    // repeated chromosome (chromosome1, chromosome2), reference variant (variant1), \n    // and positional info (position1, position2)\n    // and renames r_squared to correlation\n    _normalizeResponse(raw_response, request_options) {\n        const { ld_refvar } = request_options;\n\n        // ld_refvar undefined b/c no association data in span\n        if (ld_refvar == null) {\n            return [];\n        } \n\n        const [chromosome, position1, ...rest] = ld_refvar.split(':');\n        const ldSelf = {\n            variant1: ld_refvar,\n            variant2: ld_refvar,\n            chromosome1: chromosome,\n            chromosome2: chromosome,\n            correlation: 1.0,\n            position1: parseInt(position1),\n            position2: parseInt(position1),\n        };\n\n\n        // no variants in LD, return self\n        if (raw_response.data.linked_variant[0] == null) {\n            return [ ldSelf ]\n        }\n\n        const records = raw_response.data.linked_variant.map((lv, index) => (\n            {\n                variant1: ld_refvar,\n                variant2: lv,\n                chromosome1: chromosome,\n                chromosome2: chromosome,\n                correlation: raw_response.data.r_squared[index],\n                position1: parseInt(position1),\n                position2: parseInt(lv.split(':')[1])\n            }));\n\n        records.push(ldSelf);\n\n        return records;\n    };\n\n}\n\n//note that other sources have to be transformed into array of objects, but not LD source....\n/*LDLZSource.prototype.*/\n\nexport class CustomGeneAdapter extends GeneLZ {\n    _getURL(request_options) {\n        const { chr, start, end } = request_options;\n        return `${this._url}/gene?chromosome=${chr}&start=${Math.trunc(start)}&end=${Math.trunc(end)}`;\n    }\n\n    _buildRequestOptions(plot_state, ...dependent_data) {\n        const initialState = this._config.initial_state;\n\n        const requestOptions = Object.assign({\n            chr: plot_state.chr ? plot_state.chr : initialState.chr,\n            start: plot_state.chr ? plot_state.start : initialState.start,\n            end: plot_state.chr ? plot_state.end : initialState.end\n        }, plot_state);\n\n        return requestOptions;\n    }\n}\n"],"names":["AssociationLZ","LocusZoom","Adapters","get","LDServer","GeneLZ","RecombLZ","CustomAssociationAdapter","_getURL","request_options","chr","start","end","track","this","_url","Math","trunc","_buildRequestOptions","plot_state","dependent_data","initialState","_config","initial_state","Object","assign","_normalizeResponse","raw_response","response","JSON","parse","data","variant","map","index","pvalue","log_pvalue","chromosome","test_allele","position","parseInt","CustomRecombAdapter","CustomLDServerAdapter","constructor","config","super","__find_ld_refvar","state","assoc_data","assoc_variant_name","_findPrefixedKey","assoc_logp_name","refvar","best_hit","ldrefvar","find","item","best_logp","hasOwnProperty","lz_is_ld_refvar","ld_population","ld_refvar","Error","base","arguments","length","_skip_request","population","DEFAULT_LD_POPULATION","position1","rest","split","ldSelf","variant1","variant2","chromosome1","chromosome2","correlation","position2","linked_variant","records","lv","r_squared","push","CustomGeneAdapter"],"mappings":"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"}